{"mappings":"khBAAA,aACAA,OAAOC,eAAeC,EAAAC,QAAS,aAAc,CACzCC,OAAO,IAEXF,EAAAC,QAAQE,QACR,SAAyBC,EAAKC,EAAKH,GAC3BG,KAAOD,EACPN,OAAOC,eAAeK,EAAKC,EAAK,CAC5BH,MAAOA,EACPI,YAAY,EACZC,cAAc,EACdC,UAAU,IAGdJ,EAAIC,GAAOH,EAEf,OAAOE,C,cCfXN,OAAOC,eAAeU,EAAS,aAAc,CACzCP,OAAO,IAEXO,EAAQN,QACR,SAAyBO,EAAUC,GAC/B,KAAMD,aAAoBC,GACtB,MAAM,IAAIC,UAAU,oC,WCG5B,SAASC,EAAkBC,EAAQC,GAC/B,IAAI,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAI,CACjC,IAAIE,EAAaH,EAAMC,GACvBE,EAAWZ,WAAaY,EAAWZ,aAAc,EACjDY,EAAWX,cAAe,EACtB,UAAWW,IAAYA,EAAWV,UAAW,GACjDV,OAAOC,eAAee,EAAQI,EAAWb,IAAKa,E,EAftDpB,OAAOC,eAAeoB,EAAS,aAAc,CACzCjB,OAAO,IAEXiB,EAAQhB,QACR,SAAsBQ,EAAaS,EAAYC,GACvCD,GAAYP,EAAkBF,EAAYW,UAAWF,GACrDC,GAAaR,EAAkBF,EAAaU,GAChD,OAAOV,C,WCPXb,OAAOC,eAAewB,EAAS,aAAc,CACzCrB,OAAO,IAEXqB,EAAQpB,QAER,SAAuBW,GACnB,IAAI,IAAIE,EAAI,EAAGA,EAAIQ,UAAUP,OAAQD,IAAI,CACrC,IAAIS,EAAyB,MAAhBD,UAAUR,GAAaQ,UAAUR,GAAK,GAC/CU,EAAU5B,OAAO6B,KAAKF,GACkB,mBAAjC3B,OAAO8B,wBACdF,EAAUA,EAAQG,OAAO/B,OAAO8B,sBAAsBH,GAAQK,QAAO,SAASC,GAC1E,OAAOjC,OAAOkC,yBAAyBP,EAAQM,GAAKzB,U,MAG5DoB,EAAQO,SAAQ,SAAS5B,GACrB6B,EAAqB/B,QAAQW,EAAQT,EAAKoB,EAAOpB,G,IAGzD,OAAOS,C,EAdX,IAgBgCV,EAhB5B8B,GAgB4B9B,EAhBa+B,EAAA,WAiB3B/B,EAAIgC,WAAahC,EAAM,CACjCD,QAASC,GCvBjB,IAAMiC,EAAsB,CAC1BC,YAAa,SAACC,GACZ,IAAMC,EAAKD,EAAME,aAAa,0BAC9B,OAAOC,OAAOC,oBAAoBC,UAAUJ,E,EAE9CI,UAAW,GAEXC,cAAe,W,MAA8B,aAAxBC,SAASC,U,GAGV,iBAAXL,SACTA,OAAOC,oBAAsBN,GAI/B,IACMW,EAAW,CAEfC,eAAe,EAGfC,oBAAoB,EAEpBC,gBAAiB,SAEjBC,gBAAiB,GAEjBC,kBAAmB,KAEnBC,kBAAmB,KAEnBC,iBAAkB,GAElBC,iBAAiB,EAEjBC,YAAa,KAEbC,YAAa,GAEbC,eAAgB,GAEhBC,mBAAoB,KAEpBC,cAAc,EAEdC,cAAe,GAEfC,sBAAuB,SAEvBC,mBAAoB,CAAC,KAAM,MAE3BC,kBAAkB,EAElBC,WAAW,EAEXC,YAAa,IAyBTC,EAAc,SAAChE,EAAKiE,GAExB,IADA,IAAM1C,EAAO7B,OAAO6B,KAAKvB,GAChBY,EAAI,EAAGA,EAAIW,EAAKV,OAAQD,IAC/BqD,EAAS1C,EAAKX,GAAIZ,EAAIuB,EAAKX,I,EAKzBsD,EAAkB,SAACC,GACvBH,EAAY1B,OAAOC,oBAAoBC,WAAW,SAACvC,GACjDqC,OAAOC,oBAAoBC,UAAUvC,GAAKkE,I,KA4jD9ClC,EAAoBmC,eAAiB,W,OAAMC,Y,EAG3C,IAAMC,EAAe,SAACC,EAAMC,EAAeC,GAEzC,IAAMC,EAAShC,SAASiC,cAAc,UACtCD,EAAOE,OAAS,WACdV,EAAgB,eACZM,GACFA,G,EAGJE,EAAOG,QAAU,WACfX,EAAgB,4BACZO,GACFA,G,EAGJC,EAAOI,UAAY,iBACnBJ,EAAOK,OAAQ,EACfL,EAAOM,IAAMT,EACb7B,SAASuC,KAAKC,YAAYR,E,EAI5BzC,EAAoBkD,UAAY,SAACZ,GAK/B,IACGjC,OAAO8C,oBACP9C,OAAOC,oBAAoB8C,0BAC5B,CAKA,GAHA/C,OAAOC,oBAAoB8C,2BAA4B,EAGhC,oBAAZC,QACT,OAAO,IAAIA,SAAQ,SAACC,EAASC,G,OAC3BlB,EAAaC,EAAMgB,EAASC,E,IAGhClB,EAAaC,E,CAEf,OAAO,I,EAITtC,EAAoBwD,SAAW7C,EAG/BX,EAAoByD,QAAU,gB","sources":["node_modules/@swc/helpers/lib/_define_property.js","node_modules/@swc/helpers/lib/_class_call_check.js","node_modules/@swc/helpers/lib/_create_class.js","node_modules/@swc/helpers/lib/_object_spread.js","src/js/intlTelInput.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _defineProperty;\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _classCallCheck;\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _createClass;\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _objectSpread;\nvar _defineProperty = _interopRequireDefault(require(\"./_define_property\"));\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            (0, _defineProperty).default(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n","const intlTelInputGlobals = {\n  getInstance: (input) => {\n    const id = input.getAttribute(\"data-intl-tel-input-id\");\n    return window.intlTelInputGlobals.instances[id];\n  },\n  instances: {},\n  // using a global like this allows us to mock it in the tests\n  documentReady: () => document.readyState === \"complete\"\n};\n\nif (typeof window === \"object\") {\n  window.intlTelInputGlobals = intlTelInputGlobals;\n}\n\n// these vars persist through all instances of the plugin\nlet id = 0;\nconst defaults = {\n  // whether or not to allow the dropdown\n  allowDropdown: true,\n  // auto insert dial code (A) on init, (B) on user selecting a country, (C) on calling setCountry\n  // also listen for blur/submit and auto remove dial code if that's all there is\n  autoInsertDialCode: false,\n  // add a placeholder in the input with an example number for the selected country\n  autoPlaceholder: \"polite\",\n  // modify the parentClass\n  customContainer: \"\",\n  // modify the auto placeholder\n  customPlaceholder: null,\n  // append menu to specified element\n  dropdownContainer: null,\n  // don't display these countries\n  excludeCountries: [],\n  // format the input value during initialisation and on setNumber\n  formatOnDisplay: true,\n  // geoIp lookup function\n  geoIpLookup: null,\n  // inject a hidden input with this name, and on submit, populate it with the result of getNumber\n  hiddenInput: \"\",\n  // initial country\n  initialCountry: \"\",\n  // localized country names e.g. { 'de': 'Deutschland' }\n  localizedCountries: null,\n  // national vs international formatting for numbers e.g. placeholders and displaying existing numbers\n  nationalMode: true,\n  // display only these countries\n  onlyCountries: [],\n  // number type to use for placeholders\n  placeholderNumberType: \"MOBILE\",\n  // the countries at the top of the list. defaults to united states and united kingdom\n  preferredCountries: [\"us\", \"gb\"],\n  // display the country dial code next to the selected flag\n  separateDialCode: false,\n  // option to hide the flags - must be used with separateDialCode, or allowDropdown=false\n  showFlags: true,\n  // specify the path to the libphonenumber script to enable validation/formatting\n  utilsScript: \"\"\n};\n// https://en.wikipedia.org/wiki/List_of_North_American_Numbering_Plan_area_codes#Non-geographic_area_codes\nconst regionlessNanpNumbers = [\n  \"800\",\n  \"822\",\n  \"833\",\n  \"844\",\n  \"855\",\n  \"866\",\n  \"877\",\n  \"880\",\n  \"881\",\n  \"882\",\n  \"883\",\n  \"884\",\n  \"885\",\n  \"886\",\n  \"887\",\n  \"888\",\n  \"889\"\n];\n\n// utility function to iterate over an object. can't use Object.entries or native forEach because\n// of IE11\nconst forEachProp = (obj, callback) => {\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    callback(keys[i], obj[keys[i]]);\n  }\n};\n\n// run a method on each instance of the plugin\nconst forEachInstance = (method) => {\n  forEachProp(window.intlTelInputGlobals.instances, (key) => {\n    window.intlTelInputGlobals.instances[key][method]();\n  });\n};\n\n// this is our plugin class that we will create an instance of\n// eslint-disable-next-line no-unused-vars\nclass Iti {\n  constructor(input, options) {\n    this.id = id++;\n    this.telInput = input;\n\n    this.activeItem = null;\n    this.highlightedItem = null;\n\n    // process specified options / defaults\n    // alternative to Object.assign, which isn't supported by IE11\n    const customOptions = options || {};\n    this.options = {};\n    forEachProp(defaults, (key, value) => {\n      this.options[key] = customOptions.hasOwnProperty(key)\n        ? customOptions[key]\n        : value;\n    });\n\n    this.hadInitialPlaceholder = Boolean(input.getAttribute(\"placeholder\"));\n  }\n\n  _init() {\n    // if in nationalMode, do not insert dial codes\n    if (this.options.nationalMode) {\n      this.options.autoInsertDialCode = false;\n    }\n\n    // if separateDialCode enabled, do not insert dial codes\n    if (this.options.separateDialCode) {\n      this.options.autoInsertDialCode = false;\n    }\n\n    // force showFlags=true if there's a dropdown and we're not displaying the dial code,\n    // as otherwise you just have a down arrow on it's own which doesn't make sense\n    const forceShowFlags =\n      this.options.allowDropdown && !this.options.separateDialCode;\n    if (!this.options.showFlags && forceShowFlags) {\n      this.options.showFlags = true;\n    }\n\n    // we cannot just test screen size as some smartphones/website meta tags will report desktop\n    // resolutions\n    // Note: for some reason jasmine breaks if you put this in the main Plugin function with the\n    // rest of these declarations\n    // Note: to target Android Mobiles (and not Tablets), we must find 'Android' and 'Mobile'\n    this.isMobile =\n      /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n        navigator.userAgent\n      );\n\n    if (this.isMobile) {\n      // trigger the mobile dropdown css\n      document.body.classList.add(\"iti-mobile\");\n\n      // on mobile, we want a full screen dropdown, so we must append it to the body\n      if (!this.options.dropdownContainer) {\n        this.options.dropdownContainer = document.body;\n      }\n    }\n\n    // these promises get resolved when their individual requests complete\n    // this way the dev can do something like iti.promise.then(...) to know when all requests are\n    // complete\n    if (typeof Promise !== \"undefined\") {\n      const autoCountryPromise = new Promise((resolve, reject) => {\n        this.resolveAutoCountryPromise = resolve;\n        this.rejectAutoCountryPromise = reject;\n      });\n      const utilsScriptPromise = new Promise((resolve, reject) => {\n        this.resolveUtilsScriptPromise = resolve;\n        this.rejectUtilsScriptPromise = reject;\n      });\n      this.promise = Promise.all([autoCountryPromise, utilsScriptPromise]);\n    } else {\n      // prevent errors when Promise doesn't exist\n      this.resolveAutoCountryPromise = this.rejectAutoCountryPromise = () => {};\n      this.resolveUtilsScriptPromise = this.rejectUtilsScriptPromise = () => {};\n    }\n\n    // in various situations there could be no country selected initially, but we need to be able\n    // to assume this variable exists\n    this.selectedCountryData = {};\n\n    // process all the data: onlyCountries, excludeCountries, preferredCountries etc\n    this._processCountryData();\n\n    // generate the markup\n    this._generateMarkup();\n\n    // set the initial state of the input value and the selected flag\n    this._setInitialState();\n\n    // start all of the event listeners: autoInsertDialCode, input keydown, selectedFlag click\n    this._initListeners();\n\n    // utils script, and auto country\n    this._initRequests();\n  }\n\n  /********************\n   *  PRIVATE METHODS\n   ********************/\n\n  // prepare all of the country data, including onlyCountries, excludeCountries and\n  // preferredCountries options\n  _processCountryData() {\n    // process onlyCountries or excludeCountries array if present\n    this._processAllCountries();\n\n    // process the countryCodes map\n    this._processCountryCodes();\n\n    // process the preferredCountries\n    this._processPreferredCountries();\n\n    // translate countries according to localizedCountries option\n    if (this.options.localizedCountries) {\n      this._translateCountriesByLocale();\n    }\n\n    // sort countries by name\n    if (this.options.onlyCountries.length || this.options.localizedCountries) {\n      this.countries.sort(this._countryNameSort);\n    }\n  }\n\n  // add a country code to this.countryCodes\n  _addCountryCode(iso2, countryCode, priority) {\n    if (countryCode.length > this.countryCodeMaxLen) {\n      this.countryCodeMaxLen = countryCode.length;\n    }\n    if (!this.countryCodes.hasOwnProperty(countryCode)) {\n      this.countryCodes[countryCode] = [];\n    }\n    // bail if we already have this country for this countryCode\n    for (let i = 0; i < this.countryCodes[countryCode].length; i++) {\n      if (this.countryCodes[countryCode][i] === iso2) {\n        return;\n      }\n    }\n    // check for undefined as 0 is falsy\n    const index =\n      priority !== undefined ? priority : this.countryCodes[countryCode].length;\n    this.countryCodes[countryCode][index] = iso2;\n  }\n\n  // process onlyCountries or excludeCountries array if present\n  _processAllCountries() {\n    if (this.options.onlyCountries.length) {\n      const lowerCaseOnlyCountries = this.options.onlyCountries.map((country) =>\n        country.toLowerCase()\n      );\n      this.countries = allCountries.filter(\n        (country) => lowerCaseOnlyCountries.indexOf(country.iso2) > -1\n      );\n    } else if (this.options.excludeCountries.length) {\n      const lowerCaseExcludeCountries = this.options.excludeCountries.map(\n        (country) => country.toLowerCase()\n      );\n      this.countries = allCountries.filter(\n        (country) => lowerCaseExcludeCountries.indexOf(country.iso2) === -1\n      );\n    } else {\n      this.countries = allCountries;\n    }\n  }\n\n  // Translate Countries by object literal provided on config\n  _translateCountriesByLocale() {\n    for (let i = 0; i < this.countries.length; i++) {\n      const iso = this.countries[i].iso2.toLowerCase();\n      if (this.options.localizedCountries.hasOwnProperty(iso)) {\n        this.countries[i].name = this.options.localizedCountries[iso];\n      }\n    }\n  }\n\n  // sort by country name\n  _countryNameSort(a, b) {\n    if (a.name < b.name) {\n      return -1;\n    }\n    if (a.name > b.name) {\n      return 1;\n    }\n    return 0;\n  }\n\n  // process the countryCodes map\n  _processCountryCodes() {\n    this.countryCodeMaxLen = 0;\n    // here we store just dial codes\n    this.dialCodes = {};\n    // here we store \"country codes\" (both dial codes and their area codes)\n    this.countryCodes = {};\n\n    // first: add dial codes\n    for (let i = 0; i < this.countries.length; i++) {\n      const c = this.countries[i];\n      if (!this.dialCodes[c.dialCode]) {\n        this.dialCodes[c.dialCode] = true;\n      }\n      this._addCountryCode(c.iso2, c.dialCode, c.priority);\n    }\n\n    // next: add area codes\n    // this is a second loop over countries, to make sure we have all of the \"root\" countries\n    // already in the map, so that we can access them, as each time we add an area code substring\n    // to the map, we also need to include the \"root\" country's code, as that also matches\n    for (let i = 0; i < this.countries.length; i++) {\n      const c = this.countries[i];\n      // area codes\n      if (c.areaCodes) {\n        const rootCountryCode = this.countryCodes[c.dialCode][0];\n        // for each area code\n        for (let j = 0; j < c.areaCodes.length; j++) {\n          const areaCode = c.areaCodes[j];\n          // for each digit in the area code to add all partial matches as well\n          for (let k = 1; k < areaCode.length; k++) {\n            const partialDialCode = c.dialCode + areaCode.substr(0, k);\n            // start with the root country, as that also matches this dial code\n            this._addCountryCode(rootCountryCode, partialDialCode);\n            this._addCountryCode(c.iso2, partialDialCode);\n          }\n          // add the full area code\n          this._addCountryCode(c.iso2, c.dialCode + areaCode);\n        }\n      }\n    }\n  }\n\n  // process preferred countries - iterate through the preferences, fetching the country data for\n  // each one\n  _processPreferredCountries() {\n    this.preferredCountries = [];\n    for (let i = 0; i < this.options.preferredCountries.length; i++) {\n      const countryCode = this.options.preferredCountries[i].toLowerCase();\n      const countryData = this._getCountryData(countryCode, false, true);\n      if (countryData) {\n        this.preferredCountries.push(countryData);\n      }\n    }\n  }\n\n  // create a DOM element\n  _createEl(name, attrs, container) {\n    const el = document.createElement(name);\n    if (attrs) {\n      forEachProp(attrs, (key, value) => el.setAttribute(key, value));\n    }\n    if (container) {\n      container.appendChild(el);\n    }\n    return el;\n  }\n\n  // generate all of the markup for the plugin: the selected flag overlay, and the dropdown\n  _generateMarkup() {\n    // if autocomplete does not exist on the element and its form, then\n    // prevent autocomplete as there's no safe, cross-browser event we can react to, so it can\n    // easily put the plugin in an inconsistent state e.g. the wrong flag selected for the\n    // autocompleted number, which on submit could mean wrong number is saved\n    if (\n      !this.telInput.hasAttribute(\"autocomplete\") &&\n      !(this.telInput.form && this.telInput.form.hasAttribute(\"autocomplete\"))\n    ) {\n      this.telInput.setAttribute(\"autocomplete\", \"off\");\n    }\n\n    const {\n      allowDropdown,\n      separateDialCode,\n      showFlags,\n      customContainer,\n      hiddenInput,\n      dropdownContainer\n    } = this.options;\n\n    // containers (mostly for positioning)\n    let parentClass = \"iti\";\n    if (allowDropdown) {\n      parentClass += \" iti--allow-dropdown\";\n    }\n    if (separateDialCode) {\n      parentClass += \" iti--separate-dial-code\";\n    }\n    if (showFlags) {\n      parentClass += \" iti--show-flags\";\n    }\n    if (customContainer) {\n      parentClass += ` ${customContainer}`;\n    }\n\n    const wrapper = this._createEl(\"div\", { class: parentClass });\n    this.telInput.parentNode.insertBefore(wrapper, this.telInput);\n    // only hide the flagsContainer if allowDropdown, showFlags and separateDialCode are all false\n    const showFlagsContainer = allowDropdown || showFlags || separateDialCode;\n    if (showFlagsContainer) {\n      this.flagsContainer = this._createEl(\n        \"div\",\n        { class: \"iti__flag-container\" },\n        wrapper\n      );\n    }\n    wrapper.appendChild(this.telInput);\n\n    // selected flag (displayed to left of input)\n    // using Aria tags for \"Select-Only Combobox Example\"\n    // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/\n    if (showFlagsContainer) {\n      this.selectedFlag = this._createEl(\n        \"div\",\n        {\n          class: \"iti__selected-flag\",\n          ...(allowDropdown && {\n            role: \"combobox\",\n            \"aria-haspopup\": \"listbox\",\n            \"aria-controls\": `iti-${this.id}__country-listbox`,\n            \"aria-expanded\": \"false\",\n            \"aria-label\": \"Telephone country code\"\n          })\n        },\n        this.flagsContainer\n      );\n    }\n    if (showFlags) {\n      this.selectedFlagInner = this._createEl(\n        \"div\",\n        { class: \"iti__flag\" },\n        this.selectedFlag\n      );\n    }\n\n    if (this.selectedFlag && this.telInput.disabled) {\n      this.selectedFlag.setAttribute(\"aria-disabled\", \"true\");\n    }\n\n    if (separateDialCode) {\n      this.selectedDialCode = this._createEl(\n        \"div\",\n        { class: \"iti__selected-dial-code\" },\n        this.selectedFlag\n      );\n    }\n\n    if (allowDropdown) {\n      if (!this.telInput.disabled) {\n        // make element focusable and tab navigable\n        this.selectedFlag.setAttribute(\"tabindex\", \"0\");\n      }\n\n      this.dropdownArrow = this._createEl(\n        \"div\",\n        { class: \"iti__arrow\" },\n        this.selectedFlag\n      );\n\n      // country dropdown: preferred countries, then divider, then all countries\n      this.countryList = this._createEl(\"ul\", {\n        class: \"iti__country-list iti__hide\",\n        id: `iti-${this.id}__country-listbox`,\n        role: \"listbox\",\n        \"aria-label\": \"List of countries\"\n      });\n      if (this.preferredCountries.length) {\n        this._appendListItems(this.preferredCountries, \"iti__preferred\", true);\n        this._createEl(\n          \"li\",\n          {\n            class: \"iti__divider\",\n            role: \"separator\",\n            \"aria-disabled\": \"true\"\n          },\n          this.countryList\n        );\n      }\n      this._appendListItems(this.countries, \"iti__standard\");\n\n      // create dropdownContainer markup\n      if (dropdownContainer) {\n        this.dropdown = this._createEl(\"div\", { class: \"iti iti--container\" });\n        this.dropdown.appendChild(this.countryList);\n      } else {\n        this.flagsContainer.appendChild(this.countryList);\n      }\n    }\n\n    if (hiddenInput) {\n      let hiddenInputName = hiddenInput;\n      const name = this.telInput.getAttribute(\"name\");\n      if (name) {\n        const i = name.lastIndexOf(\"[\");\n        // if input name contains square brackets, then give the hidden input the same name,\n        // replacing the contents of the last set of brackets with the given hiddenInput name\n        if (i !== -1) {\n          hiddenInputName = `${name.substr(0, i)}[${hiddenInputName}]`;\n        }\n      }\n      this.hiddenInput = this._createEl(\"input\", {\n        type: \"hidden\",\n        name: hiddenInputName\n      });\n      wrapper.appendChild(this.hiddenInput);\n    }\n  }\n\n  // add a country <li> to the countryList <ul> container\n  _appendListItems(countries, className, preferred) {\n    // we create so many DOM elements, it is faster to build a temp string\n    // and then add everything to the DOM in one go at the end\n    let tmp = \"\";\n    // for each country\n    for (let i = 0; i < countries.length; i++) {\n      const c = countries[i];\n      const idSuffix = preferred ? \"-preferred\" : \"\";\n      // open the list item\n      tmp += `<li class='iti__country ${className}' tabIndex='-1' id='iti-${this.id}__item-${c.iso2}${idSuffix}' role='option' data-dial-code='${c.dialCode}' data-country-code='${c.iso2}' aria-selected='false'>`;\n      // add the flag\n      if (this.options.showFlags) {\n        tmp += `<div class='iti__flag-box'><div class='iti__flag iti__${c.iso2}'></div></div>`;\n      }\n      // and the country name and dial code\n      tmp += `<span class='iti__country-name'>${c.name}</span>`;\n      tmp += `<span class='iti__dial-code'>+${c.dialCode}</span>`;\n      // close the list item\n      tmp += \"</li>\";\n    }\n    this.countryList.insertAdjacentHTML(\"beforeend\", tmp);\n  }\n\n  // set the initial state of the input value and the selected flag by:\n  // 1. extracting a dial code from the given number\n  // 2. using explicit initialCountry\n  // 3. picking the first preferred country\n  // 4. picking the first country\n  _setInitialState() {\n    // fix firefox bug: when first load page (with input with value set to number with intl dial\n    // code) and initialising plugin removes the dial code from the input, then refresh page,\n    // and we try to init plugin again but this time on number without dial code so get grey flag\n    const attributeValue = this.telInput.getAttribute(\"value\");\n    const inputValue = this.telInput.value;\n    const useAttribute =\n      attributeValue &&\n      attributeValue.charAt(0) === \"+\" &&\n      (!inputValue || inputValue.charAt(0) !== \"+\");\n    const val = useAttribute ? attributeValue : inputValue;\n    const dialCode = this._getDialCode(val);\n    const isRegionlessNanp = this._isRegionlessNanp(val);\n    const { initialCountry, autoInsertDialCode } = this.options;\n\n    // if we already have a dial code, and it's not a regionlessNanp, we can go ahead and set the\n    // flag, else fall back to the default country\n    if (dialCode && !isRegionlessNanp) {\n      this._updateFlagFromNumber(val);\n    } else if (initialCountry !== \"auto\") {\n      // see if we should select a flag\n      if (initialCountry) {\n        this._setFlag(initialCountry.toLowerCase());\n      } else {\n        if (dialCode && isRegionlessNanp) {\n          // has intl dial code, is regionless nanp, and no initialCountry, so default to US\n          this._setFlag(\"us\");\n        } else {\n          // no dial code and no initialCountry, so default to first in list\n          this.defaultCountry = this.preferredCountries.length\n            ? this.preferredCountries[0].iso2\n            : this.countries[0].iso2;\n          if (!val) {\n            this._setFlag(this.defaultCountry);\n          }\n        }\n      }\n\n      // if empty and autoInsertDialCode then insert the dial code\n      if (!val && autoInsertDialCode) {\n        this.telInput.value = `+${this.selectedCountryData.dialCode}`;\n      }\n    }\n    // NOTE: if initialCountry is set to auto, that will be handled separately\n\n    // format - note this wont be run after _updateDialCode as that's only called if no val\n    if (val) {\n      this._updateValFromNumber(val);\n    }\n  }\n\n  // initialise the main event listeners: input keyup, and click selected flag\n  _initListeners() {\n    this._initKeyListeners();\n    if (this.options.autoInsertDialCode) {\n      this._initBlurListeners();\n    }\n    if (this.options.allowDropdown) {\n      this._initDropdownListeners();\n    }\n    if (this.hiddenInput) {\n      this._initHiddenInputListener();\n    }\n  }\n\n  // update hidden input on form submit\n  _initHiddenInputListener() {\n    this._handleHiddenInputSubmit = () => {\n      this.hiddenInput.value = this.getNumber();\n    };\n    if (this.telInput.form) {\n      this.telInput.form.addEventListener(\n        \"submit\",\n        this._handleHiddenInputSubmit\n      );\n    }\n  }\n\n  // iterate through parent nodes to find the closest label ancestor, if it exists\n  _getClosestLabel() {\n    let el = this.telInput;\n    while (el && el.tagName !== \"LABEL\") {\n      el = el.parentNode;\n    }\n    return el;\n  }\n\n  // initialise the dropdown listeners\n  _initDropdownListeners() {\n    // hack for input nested inside label (which is valid markup): clicking the selected-flag to\n    // open the dropdown would then automatically trigger a 2nd click on the input which would\n    // close it again\n    this._handleLabelClick = (e) => {\n      // if the dropdown is closed, then focus the input, else ignore the click\n      if (this.countryList.classList.contains(\"iti__hide\")) {\n        this.telInput.focus();\n      } else {\n        e.preventDefault();\n      }\n    };\n    const label = this._getClosestLabel();\n    if (label) {\n      label.addEventListener(\"click\", this._handleLabelClick);\n    }\n\n    // toggle country dropdown on click\n    this._handleClickSelectedFlag = () => {\n      // only intercept this event if we're opening the dropdown\n      // else let it bubble up to the top (\"click-off-to-close\" listener)\n      // we cannot just stopPropagation as it may be needed to close another instance\n      if (\n        this.countryList.classList.contains(\"iti__hide\") &&\n        !this.telInput.disabled &&\n        !this.telInput.readOnly\n      ) {\n        this._showDropdown();\n      }\n    };\n    this.selectedFlag.addEventListener(\"click\", this._handleClickSelectedFlag);\n\n    // open dropdown list if currently focused\n    this._handleFlagsContainerKeydown = (e) => {\n      const isDropdownHidden = this.countryList.classList.contains(\"iti__hide\");\n\n      if (\n        isDropdownHidden &&\n        [\"ArrowUp\", \"Up\", \"ArrowDown\", \"Down\", \" \", \"Enter\"].indexOf(e.key) !==\n          -1\n      ) {\n        // prevent form from being submitted if \"ENTER\" was pressed\n        e.preventDefault();\n        // prevent event from being handled again by document\n        e.stopPropagation();\n        this._showDropdown();\n      }\n\n      // allow navigation from dropdown to input on TAB\n      if (e.key === \"Tab\") {\n        this._closeDropdown();\n      }\n    };\n    this.flagsContainer.addEventListener(\n      \"keydown\",\n      this._handleFlagsContainerKeydown\n    );\n  }\n\n  // init many requests: utils script / geo ip lookup\n  _initRequests() {\n    // if the user has specified the path to the utils script, fetch it on window.load, else resolve\n    if (this.options.utilsScript && !window.intlTelInputUtils) {\n      // if the plugin is being initialised after the window.load event has already been fired\n      if (window.intlTelInputGlobals.documentReady()) {\n        window.intlTelInputGlobals.loadUtils(this.options.utilsScript);\n      } else {\n        // wait until the load event so we don't block any other requests e.g. the flags image\n        window.addEventListener(\"load\", () => {\n          window.intlTelInputGlobals.loadUtils(this.options.utilsScript);\n        });\n      }\n    } else {\n      this.resolveUtilsScriptPromise();\n    }\n\n    if (this.options.initialCountry === \"auto\") {\n      this._loadAutoCountry();\n    } else {\n      this.resolveAutoCountryPromise();\n    }\n  }\n\n  // perform the geo ip lookup\n  _loadAutoCountry() {\n    // 3 options:\n    // 1) already loaded (we're done)\n    // 2) not already started loading (start)\n    // 3) already started loading (do nothing - just wait for loading callback to fire)\n    if (window.intlTelInputGlobals.autoCountry) {\n      this.handleAutoCountry();\n    } else if (!window.intlTelInputGlobals.startedLoadingAutoCountry) {\n      // don't do this twice!\n      window.intlTelInputGlobals.startedLoadingAutoCountry = true;\n\n      if (typeof this.options.geoIpLookup === \"function\") {\n        this.options.geoIpLookup(\n          (countryCode) => {\n            window.intlTelInputGlobals.autoCountry = countryCode.toLowerCase();\n            // tell all instances the auto country is ready\n            // TODO: this should just be the current instances\n            // UPDATE: use setTimeout in case their geoIpLookup function calls this callback straight\n            // away (e.g. if they have already done the geo ip lookup somewhere else). Using\n            // setTimeout means that the current thread of execution will finish before executing\n            // this, which allows the plugin to finish initialising.\n            setTimeout(() => forEachInstance(\"handleAutoCountry\"));\n          },\n          () => forEachInstance(\"rejectAutoCountryPromise\")\n        );\n      }\n    }\n  }\n\n  // initialize any key listeners\n  _initKeyListeners() {\n    // update flag on keyup\n    this._handleKeyupEvent = () => {\n      if (this._updateFlagFromNumber(this.telInput.value)) {\n        this._triggerCountryChange();\n      }\n    };\n    this.telInput.addEventListener(\"keyup\", this._handleKeyupEvent);\n\n    // update flag on cut/paste events (now supported in all major browsers)\n    this._handleClipboardEvent = () => {\n      // hack because \"paste\" event is fired before input is updated\n      setTimeout(this._handleKeyupEvent);\n    };\n    this.telInput.addEventListener(\"cut\", this._handleClipboardEvent);\n    this.telInput.addEventListener(\"paste\", this._handleClipboardEvent);\n  }\n\n  // adhere to the input's maxlength attr\n  _cap(number) {\n    const max = this.telInput.getAttribute(\"maxlength\");\n    return max && number.length > max ? number.substr(0, max) : number;\n  }\n\n  // listen for blur/submit (for autoInsertDialCode feature)\n  _initBlurListeners() {\n    // on blur or form submit: if just a dial code then remove it\n    this._handleSubmitOrBlurEvent = () => {\n      this._removeEmptyDialCode();\n    };\n    if (this.telInput.form) {\n      this.telInput.form.addEventListener(\n        \"submit\",\n        this._handleSubmitOrBlurEvent\n      );\n    }\n    this.telInput.addEventListener(\"blur\", this._handleSubmitOrBlurEvent);\n\n    // made the decision not to trigger blur() now, because would only do anything in the case\n    // where they manually set the initial value to just a dial code, in which case they probably\n    // want it to be displayed.\n  }\n\n  // clear the input if it just contains a dial code\n  _removeEmptyDialCode() {\n    if (this.telInput.value.charAt(0) === \"+\") {\n      const numeric = this._getNumeric(this.telInput.value);\n      // if just a plus, or if just a dial code\n      if (!numeric || this.selectedCountryData.dialCode === numeric) {\n        this.telInput.value = \"\";\n      }\n    }\n  }\n\n  // extract the numeric digits from the given string\n  _getNumeric(s) {\n    return s.replace(/\\D/g, \"\");\n  }\n\n  // trigger a custom event on the input\n  _trigger(name) {\n    // have to use old school document.createEvent as IE11 doesn't support `new Event()` syntax\n    const e = document.createEvent(\"Event\");\n    e.initEvent(name, true, true); // can bubble, and is cancellable\n    this.telInput.dispatchEvent(e);\n  }\n\n  // show the dropdown\n  _showDropdown() {\n    this.countryList.classList.remove(\"iti__hide\");\n    this.selectedFlag.setAttribute(\"aria-expanded\", \"true\");\n\n    this._setDropdownPosition();\n\n    // update highlighting and scroll to active list item\n    if (this.activeItem) {\n      this._highlightListItem(this.activeItem, false);\n      this._scrollTo(this.activeItem, true);\n    }\n\n    // bind all the dropdown-related listeners: mouseover, click, click-off, keydown\n    this._bindDropdownListeners();\n\n    // update the arrow\n    this.dropdownArrow.classList.add(\"iti__arrow--up\");\n\n    this._trigger(\"open:countrydropdown\");\n  }\n\n  // make sure the el has the className or not, depending on the value of shouldHaveClass\n  _toggleClass(el, className, shouldHaveClass) {\n    if (shouldHaveClass && !el.classList.contains(className)) {\n      el.classList.add(className);\n    } else if (!shouldHaveClass && el.classList.contains(className)) {\n      el.classList.remove(className);\n    }\n  }\n\n  // decide where to position dropdown (depends on position within viewport, and scroll)\n  _setDropdownPosition() {\n    if (this.options.dropdownContainer) {\n      this.options.dropdownContainer.appendChild(this.dropdown);\n    }\n\n    if (!this.isMobile) {\n      const pos = this.telInput.getBoundingClientRect();\n      // windowTop from https://stackoverflow.com/a/14384091/217866\n      const windowTop =\n        window.pageYOffset || document.documentElement.scrollTop;\n      const inputTop = pos.top + windowTop;\n      const dropdownHeight = this.countryList.offsetHeight;\n      // dropdownFitsBelow = (dropdownBottom < windowBottom)\n      const dropdownFitsBelow =\n        inputTop + this.telInput.offsetHeight + dropdownHeight <\n        windowTop + window.innerHeight;\n      const dropdownFitsAbove = inputTop - dropdownHeight > windowTop;\n\n      // by default, the dropdown will be below the input. If we want to position it above the\n      // input, we add the dropup class.\n      this._toggleClass(\n        this.countryList,\n        \"iti__country-list--dropup\",\n        !dropdownFitsBelow && dropdownFitsAbove\n      );\n\n      // if dropdownContainer is enabled, calculate postion\n      if (this.options.dropdownContainer) {\n        // by default the dropdown will be directly over the input because it's not in the flow.\n        // If we want to position it below, we need to add some extra top value.\n        const extraTop =\n          !dropdownFitsBelow && dropdownFitsAbove\n            ? 0\n            : this.telInput.offsetHeight;\n\n        // calculate placement\n        this.dropdown.style.top = `${inputTop + extraTop}px`;\n        this.dropdown.style.left = `${pos.left + document.body.scrollLeft}px`;\n\n        // close menu on window scroll\n        this._handleWindowScroll = () => this._closeDropdown();\n        window.addEventListener(\"scroll\", this._handleWindowScroll);\n      }\n    }\n  }\n\n  // iterate through parent nodes to find the closest list item\n  _getClosestListItem(target) {\n    let el = target;\n    while (\n      el &&\n      el !== this.countryList &&\n      !el.classList.contains(\"iti__country\")\n    ) {\n      el = el.parentNode;\n    }\n    // if we reached the countryList element, then return null\n    return el === this.countryList ? null : el;\n  }\n\n  // we only bind dropdown listeners when the dropdown is open\n  _bindDropdownListeners() {\n    // when mouse over a list item, just highlight that one\n    // we add the class \"highlight\", so if they hit \"enter\" we know which one to select\n    this._handleMouseoverCountryList = (e) => {\n      // handle event delegation, as we're listening for this event on the countryList\n      const listItem = this._getClosestListItem(e.target);\n      if (listItem) {\n        this._highlightListItem(listItem, false);\n      }\n    };\n    this.countryList.addEventListener(\n      \"mouseover\",\n      this._handleMouseoverCountryList\n    );\n\n    // listen for country selection\n    this._handleClickCountryList = (e) => {\n      const listItem = this._getClosestListItem(e.target);\n      if (listItem) {\n        this._selectListItem(listItem);\n      }\n    };\n    this.countryList.addEventListener(\"click\", this._handleClickCountryList);\n\n    // click off to close\n    // (except when this initial opening click is bubbling up)\n    // we cannot just stopPropagation as it may be needed to close another instance\n    let isOpening = true;\n    this._handleClickOffToClose = () => {\n      if (!isOpening) {\n        this._closeDropdown();\n      }\n      isOpening = false;\n    };\n    document.documentElement.addEventListener(\n      \"click\",\n      this._handleClickOffToClose\n    );\n\n    // listen for up/down scrolling, enter to select, or letters to jump to country name.\n    // use keydown as keypress doesn't fire for non-char keys and we want to catch if they\n    // just hit down and hold it to scroll down (no keyup event).\n    // listen on the document because that's where key events are triggered if no input has focus\n    let query = \"\";\n    let queryTimer = null;\n    this._handleKeydownOnDropdown = (e) => {\n      // prevent down key from scrolling the whole page,\n      // and enter key from submitting a form etc\n      e.preventDefault();\n\n      // up and down to navigate\n      if (\n        e.key === \"ArrowUp\" ||\n        e.key === \"Up\" ||\n        e.key === \"ArrowDown\" ||\n        e.key === \"Down\"\n      ) {\n        this._handleUpDownKey(e.key);\n      }\n      // enter to select\n      else if (e.key === \"Enter\") {\n        this._handleEnterKey();\n      }\n      // esc to close\n      else if (e.key === \"Escape\") {\n        this._closeDropdown();\n      }\n      // alpha chars to perform search\n      // regex allows one latin alpha char or space, based on https://stackoverflow.com/a/26900132/217866)\n      else if (/^[a-zA-ZÀ-ÿа-яА-Я ]$/.test(e.key)) {\n        // jump to countries that start with the query string\n        if (queryTimer) {\n          clearTimeout(queryTimer);\n        }\n        query += e.key.toLowerCase();\n        this._searchForCountry(query);\n        // if the timer hits 1 second, reset the query\n        queryTimer = setTimeout(() => {\n          query = \"\";\n        }, 1000);\n      }\n    };\n    document.addEventListener(\"keydown\", this._handleKeydownOnDropdown);\n  }\n\n  // highlight the next/prev item in the list (and ensure it is visible)\n  _handleUpDownKey(key) {\n    let next =\n      key === \"ArrowUp\" || key === \"Up\"\n        ? this.highlightedItem.previousElementSibling\n        : this.highlightedItem.nextElementSibling;\n    if (next) {\n      // skip the divider\n      if (next.classList.contains(\"iti__divider\")) {\n        next =\n          key === \"ArrowUp\" || key === \"Up\"\n            ? next.previousElementSibling\n            : next.nextElementSibling;\n      }\n      this._highlightListItem(next, true);\n    }\n  }\n\n  // select the currently highlighted item\n  _handleEnterKey() {\n    if (this.highlightedItem) {\n      this._selectListItem(this.highlightedItem);\n    }\n  }\n\n  // find the first list item whose name starts with the query string\n  _searchForCountry(query) {\n    for (let i = 0; i < this.countries.length; i++) {\n      if (this._startsWith(this.countries[i].name, query)) {\n        const listItem = this.countryList.querySelector(\n          `#iti-${this.id}__item-${this.countries[i].iso2}`\n        );\n        // update highlighting and scroll\n        this._highlightListItem(listItem, false);\n        this._scrollTo(listItem, true);\n        break;\n      }\n    }\n  }\n\n  // check if string a starts with string b\n  _startsWith(a, b) {\n    return a.substr(0, b.length).toLowerCase() === b;\n  }\n\n  // update the input's value to the given val (format first if possible)\n  // NOTE: this is called from _setInitialState, handleUtils and setNumber\n  _updateValFromNumber(originalNumber) {\n    let number = originalNumber;\n    if (\n      this.options.formatOnDisplay &&\n      window.intlTelInputUtils &&\n      this.selectedCountryData\n    ) {\n      const useNational =\n        this.options.nationalMode ||\n        (number.charAt(0) !== \"+\" && !this.options.separateDialCode);\n      const { NATIONAL, INTERNATIONAL } = intlTelInputUtils.numberFormat;\n      const format = useNational ? NATIONAL : INTERNATIONAL;\n      number = intlTelInputUtils.formatNumber(\n        number,\n        this.selectedCountryData.iso2,\n        format\n      );\n    }\n\n    number = this._beforeSetNumber(number);\n    this.telInput.value = number;\n  }\n\n  // check if need to select a new flag based on the given number\n  // Note: called from _setInitialState, keyup handler, setNumber\n  _updateFlagFromNumber(originalNumber) {\n    // if we already have US/Canada selected, make sure the number starts\n    // with a +1 so _getDialCode will be able to extract the area code\n    // update: if we dont yet have selectedCountryData, but we're here (trying to update the flag\n    // from the number), that means we're initialising the plugin with a number that already has a\n    // dial code, so fine to ignore this bit\n    let number = originalNumber;\n    const selectedDialCode = this.selectedCountryData.dialCode;\n    const isNanp = selectedDialCode === \"1\";\n    if (number && isNanp && number.charAt(0) !== \"+\") {\n      if (number.charAt(0) !== \"1\") {\n        number = `1${number}`;\n      }\n      number = `+${number}`;\n    }\n\n    // if separateDialCode enabled, then consider the selected dial code to be part of the number\n    if (\n      this.options.separateDialCode &&\n      selectedDialCode &&\n      number.charAt(0) !== \"+\"\n    ) {\n      number = `+${selectedDialCode}${number}`;\n    }\n\n    // try and extract valid dial code from input\n    const dialCode = this._getDialCode(number, true);\n    const numeric = this._getNumeric(number);\n    let countryCode = null;\n    if (dialCode) {\n      const countryCodes = this.countryCodes[this._getNumeric(dialCode)];\n      // check if the right country is already selected. this should be false if the number is\n      // longer than the matched dial code because in this case we need to make sure that if\n      // there are multiple country matches, that the first one is selected (note: we could\n      // just check that here, but it requires the same loop that we already have later)\n      const alreadySelected =\n        countryCodes.indexOf(this.selectedCountryData.iso2) !== -1 &&\n        numeric.length <= dialCode.length - 1;\n      const isRegionlessNanpNumber =\n        selectedDialCode === \"1\" && this._isRegionlessNanp(numeric);\n\n      // only update the flag if:\n      // A) NOT (we currently have a NANP flag selected, and the number is a regionlessNanp)\n      // AND\n      // B) the right country is not already selected\n      if (!isRegionlessNanpNumber && !alreadySelected) {\n        // if using onlyCountries option, countryCodes[0] may be empty, so we must find the first\n        // non-empty index\n        for (let j = 0; j < countryCodes.length; j++) {\n          if (countryCodes[j]) {\n            countryCode = countryCodes[j];\n            break;\n          }\n        }\n      }\n    } else if (number.charAt(0) === \"+\" && numeric.length) {\n      // invalid dial code, so empty\n      // Note: use getNumeric here because the number has not been formatted yet, so could contain\n      // bad chars\n      countryCode = \"\";\n    } else if (!number || number === \"+\") {\n      // empty, or just a plus, so default\n      countryCode = this.defaultCountry;\n    }\n\n    if (countryCode !== null) {\n      return this._setFlag(countryCode);\n    }\n    return false;\n  }\n\n  // check if the given number is a regionless NANP number (expects the number to contain an\n  // international dial code)\n  _isRegionlessNanp(number) {\n    const numeric = this._getNumeric(number);\n    if (numeric.charAt(0) === \"1\") {\n      const areaCode = numeric.substr(1, 3);\n      return regionlessNanpNumbers.indexOf(areaCode) !== -1;\n    }\n    return false;\n  }\n\n  // remove highlighting from other list items and highlight the given item\n  _highlightListItem(listItem, shouldFocus) {\n    const prevItem = this.highlightedItem;\n    if (prevItem) {\n      prevItem.classList.remove(\"iti__highlight\");\n    }\n    this.highlightedItem = listItem;\n    this.highlightedItem.classList.add(\"iti__highlight\");\n    this.selectedFlag.setAttribute(\n      \"aria-activedescendant\",\n      listItem.getAttribute(\"id\")\n    );\n\n    if (shouldFocus) {\n      this.highlightedItem.focus();\n    }\n  }\n\n  // find the country data for the given country code\n  // the ignoreOnlyCountriesOption is only used during init() while parsing the onlyCountries array\n  _getCountryData(countryCode, ignoreOnlyCountriesOption, allowFail) {\n    const countryList = ignoreOnlyCountriesOption\n      ? allCountries\n      : this.countries;\n    for (let i = 0; i < countryList.length; i++) {\n      if (countryList[i].iso2 === countryCode) {\n        return countryList[i];\n      }\n    }\n    if (allowFail) {\n      return null;\n    }\n    throw new Error(`No country data for '${countryCode}'`);\n  }\n\n  // select the given flag, update the placeholder, title, and the active list item\n  // Note: called from _setInitialState, _updateFlagFromNumber, _selectListItem, setCountry\n  _setFlag(countryCode) {\n    const { allowDropdown, separateDialCode, showFlags } = this.options;\n\n    const prevCountry = this.selectedCountryData.iso2\n      ? this.selectedCountryData\n      : {};\n\n    // do this first as it will throw an error and stop if countryCode is invalid\n    this.selectedCountryData = countryCode\n      ? this._getCountryData(countryCode, false, false)\n      : {};\n    // update the defaultCountry - we only need the iso2 from now on, so just store that\n    if (this.selectedCountryData.iso2) {\n      this.defaultCountry = this.selectedCountryData.iso2;\n    }\n\n    if (showFlags) {\n      this.selectedFlagInner.setAttribute(\n        \"class\",\n        `iti__flag iti__${countryCode}`\n      );\n    }\n\n    this._setSelectedCountryFlagTitleAttribute(countryCode, separateDialCode);\n\n    if (separateDialCode) {\n      const dialCode = this.selectedCountryData.dialCode\n        ? `+${this.selectedCountryData.dialCode}`\n        : \"\";\n      this.selectedDialCode.innerHTML = dialCode;\n      // offsetWidth is zero if input is in a hidden container during initialisation\n      const selectedFlagWidth =\n        this.selectedFlag.offsetWidth || this._getHiddenSelectedFlagWidth();\n\n      // add 6px of padding after the grey selected-dial-code box, as this is what we use in the css\n      this.telInput.style.paddingLeft = `${selectedFlagWidth + 6}px`;\n    }\n\n    // and the input's placeholder\n    this._updatePlaceholder();\n\n    // update the active list item\n    if (allowDropdown) {\n      const prevItem = this.activeItem;\n      if (prevItem) {\n        prevItem.classList.remove(\"iti__active\");\n        prevItem.setAttribute(\"aria-selected\", \"false\");\n      }\n      if (countryCode) {\n        // check if there is a preferred item first, else fall back to standard\n        const nextItem =\n          this.countryList.querySelector(\n            `#iti-${this.id}__item-${countryCode}-preferred`\n          ) ||\n          this.countryList.querySelector(\n            `#iti-${this.id}__item-${countryCode}`\n          );\n        nextItem.setAttribute(\"aria-selected\", \"true\");\n        nextItem.classList.add(\"iti__active\");\n        this.activeItem = nextItem;\n      }\n    }\n\n    // return if the flag has changed or not\n    return prevCountry.iso2 !== countryCode;\n  }\n\n  _setSelectedCountryFlagTitleAttribute(countryCode, separateDialCode) {\n    if (!this.selectedFlag) {\n      return;\n    }\n\n    let title;\n    if (countryCode && !separateDialCode) {\n      title = `${this.selectedCountryData.name}: +${this.selectedCountryData.dialCode}`;\n    } else if (countryCode) {\n      // For screen reader output, we don't want to include the dial code in the reader output twice\n      // so just use the selected country name here:\n      title = this.selectedCountryData.name;\n    } else {\n      title = \"Unknown\";\n    }\n\n    this.selectedFlag.setAttribute(\"title\", title);\n  }\n\n  // when the input is in a hidden container during initialisation, we must inject some markup\n  // into the end of the DOM to calculate the correct offsetWidth\n  // NOTE: this is only used when separateDialCode is enabled, so flagsContainer and selectedFlag\n  // will definitely exist\n  _getHiddenSelectedFlagWidth() {\n    // to get the right styling to apply, all we need is a shallow clone of the container,\n    // and then to inject a deep clone of the selectedFlag element\n    const containerClone = this.telInput.parentNode.cloneNode();\n    containerClone.style.visibility = \"hidden\";\n    document.body.appendChild(containerClone);\n\n    const flagsContainerClone = this.flagsContainer.cloneNode();\n    containerClone.appendChild(flagsContainerClone);\n\n    const selectedFlagClone = this.selectedFlag.cloneNode(true);\n    flagsContainerClone.appendChild(selectedFlagClone);\n\n    const width = selectedFlagClone.offsetWidth;\n    containerClone.parentNode.removeChild(containerClone);\n    return width;\n  }\n\n  // update the input placeholder to an example number from the currently selected country\n  _updatePlaceholder() {\n    const shouldSetPlaceholder =\n      this.options.autoPlaceholder === \"aggressive\" ||\n      (!this.hadInitialPlaceholder &&\n        this.options.autoPlaceholder === \"polite\");\n    if (window.intlTelInputUtils && shouldSetPlaceholder) {\n      const numberType =\n        intlTelInputUtils.numberType[this.options.placeholderNumberType];\n      let placeholder = this.selectedCountryData.iso2\n        ? intlTelInputUtils.getExampleNumber(\n            this.selectedCountryData.iso2,\n            this.options.nationalMode,\n            numberType\n          )\n        : \"\";\n\n      placeholder = this._beforeSetNumber(placeholder);\n      if (typeof this.options.customPlaceholder === \"function\") {\n        placeholder = this.options.customPlaceholder(\n          placeholder,\n          this.selectedCountryData\n        );\n      }\n      this.telInput.setAttribute(\"placeholder\", placeholder);\n    }\n  }\n\n  // called when the user selects a list item from the dropdown\n  _selectListItem(listItem) {\n    // update selected flag and active list item\n    const flagChanged = this._setFlag(\n      listItem.getAttribute(\"data-country-code\")\n    );\n    this._closeDropdown();\n\n    this._updateDialCode(listItem.getAttribute(\"data-dial-code\"));\n\n    // focus the input\n    this.telInput.focus();\n    // put cursor at end - this fix is required for FF and IE11 (with auto inserting dial code),\n    // who try to put the cursor at the beginning the first time\n    const len = this.telInput.value.length;\n    this.telInput.setSelectionRange(len, len);\n\n    if (flagChanged) {\n      this._triggerCountryChange();\n    }\n  }\n\n  // close the dropdown and unbind any listeners\n  _closeDropdown() {\n    this.countryList.classList.add(\"iti__hide\");\n    this.selectedFlag.setAttribute(\"aria-expanded\", \"false\");\n    this.selectedFlag.removeAttribute(\"aria-activedescendant\");\n\n    // update the arrow\n    this.dropdownArrow.classList.remove(\"iti__arrow--up\");\n\n    // unbind key events\n    document.removeEventListener(\"keydown\", this._handleKeydownOnDropdown);\n    document.documentElement.removeEventListener(\n      \"click\",\n      this._handleClickOffToClose\n    );\n    this.countryList.removeEventListener(\n      \"mouseover\",\n      this._handleMouseoverCountryList\n    );\n    this.countryList.removeEventListener(\"click\", this._handleClickCountryList);\n\n    // remove menu from container\n    if (this.options.dropdownContainer) {\n      if (!this.isMobile) {\n        window.removeEventListener(\"scroll\", this._handleWindowScroll);\n      }\n      if (this.dropdown.parentNode) {\n        this.dropdown.parentNode.removeChild(this.dropdown);\n      }\n    }\n\n    this._trigger(\"close:countrydropdown\");\n  }\n\n  // check if an element is visible within it's container, else scroll until it is\n  _scrollTo(element, middle) {\n    const container = this.countryList;\n    // windowTop from https://stackoverflow.com/a/14384091/217866\n    const windowTop = window.pageYOffset || document.documentElement.scrollTop;\n    const containerHeight = container.offsetHeight;\n    const containerTop = container.getBoundingClientRect().top + windowTop;\n    const containerBottom = containerTop + containerHeight;\n    const elementHeight = element.offsetHeight;\n    const elementTop = element.getBoundingClientRect().top + windowTop;\n    const elementBottom = elementTop + elementHeight;\n    let newScrollTop = elementTop - containerTop + container.scrollTop;\n    const middleOffset = containerHeight / 2 - elementHeight / 2;\n\n    if (elementTop < containerTop) {\n      // scroll up\n      if (middle) {\n        newScrollTop -= middleOffset;\n      }\n      container.scrollTop = newScrollTop;\n    } else if (elementBottom > containerBottom) {\n      // scroll down\n      if (middle) {\n        newScrollTop += middleOffset;\n      }\n      const heightDifference = containerHeight - elementHeight;\n      container.scrollTop = newScrollTop - heightDifference;\n    }\n  }\n\n  // replace any existing dial code with the new one\n  // Note: called from _selectListItem and setCountry\n  _updateDialCode(newDialCodeBare) {\n    const inputVal = this.telInput.value;\n    // save having to pass this every time\n    const newDialCode = `+${newDialCodeBare}`;\n\n    let newNumber;\n    if (inputVal.charAt(0) === \"+\") {\n      // there's a plus so we're dealing with a replacement\n      const prevDialCode = this._getDialCode(inputVal);\n      if (prevDialCode) {\n        // current number contains a valid dial code, so replace it\n        newNumber = inputVal.replace(prevDialCode, newDialCode);\n      } else {\n        // current number contains an invalid dial code, so ditch it\n        // (no way to determine where the invalid dial code ends and the rest of the number begins)\n        newNumber = newDialCode;\n      }\n      this.telInput.value = newNumber;\n    } else if (this.options.autoInsertDialCode) {\n      if (inputVal) {\n        // there is an existing value with no dial code: prefix the new dial code\n        newNumber = newDialCode + inputVal;\n      } else {\n        newNumber = newDialCode;\n      }\n      this.telInput.value = newNumber;\n    }\n  }\n\n  // try and extract a valid international dial code from a full telephone number\n  // Note: returns the raw string inc plus character and any whitespace/dots etc\n  _getDialCode(number, includeAreaCode) {\n    let dialCode = \"\";\n    // only interested in international numbers (starting with a plus)\n    if (number.charAt(0) === \"+\") {\n      let numericChars = \"\";\n      // iterate over chars\n      for (let i = 0; i < number.length; i++) {\n        const c = number.charAt(i);\n        // if char is number (https://stackoverflow.com/a/8935649/217866)\n        if (!isNaN(parseInt(c, 10))) {\n          numericChars += c;\n          // if current numericChars make a valid dial code\n          if (includeAreaCode) {\n            if (this.countryCodes[numericChars]) {\n              // store the actual raw string (useful for matching later)\n              dialCode = number.substr(0, i + 1);\n            }\n          } else {\n            if (this.dialCodes[numericChars]) {\n              dialCode = number.substr(0, i + 1);\n              // if we're just looking for a dial code, we can break as soon as we find one\n              break;\n            }\n          }\n          // stop searching as soon as we can - in this case when we hit max len\n          if (numericChars.length === this.countryCodeMaxLen) {\n            break;\n          }\n        }\n      }\n    }\n    return dialCode;\n  }\n\n  // get the input val, adding the dial code if separateDialCode is enabled\n  _getFullNumber() {\n    const val = this.telInput.value.trim();\n    const { dialCode } = this.selectedCountryData;\n    let prefix;\n    const numericVal = this._getNumeric(val);\n\n    if (\n      this.options.separateDialCode &&\n      val.charAt(0) !== \"+\" &&\n      dialCode &&\n      numericVal\n    ) {\n      // when using separateDialCode, it is visible so is effectively part of the typed number\n      prefix = `+${dialCode}`;\n    } else {\n      prefix = \"\";\n    }\n    return prefix + val;\n  }\n\n  // remove the dial code if separateDialCode is enabled\n  // also cap the length if the input has a maxlength attribute\n  _beforeSetNumber(originalNumber) {\n    let number = originalNumber;\n    if (this.options.separateDialCode) {\n      let dialCode = this._getDialCode(number);\n      // if there is a valid dial code\n      if (dialCode) {\n        // in case _getDialCode returned an area code as well\n        dialCode = `+${this.selectedCountryData.dialCode}`;\n        // a lot of numbers will have a space separating the dial code and the main number, and\n        // some NANP numbers will have a hyphen e.g. +1 684-733-1234 - in both cases we want to get\n        // rid of it\n        // NOTE: don't just trim all non-numerics as may want to preserve an open parenthesis etc\n        const start =\n          number[dialCode.length] === \" \" || number[dialCode.length] === \"-\"\n            ? dialCode.length + 1\n            : dialCode.length;\n        number = number.substr(start);\n      }\n    }\n\n    return this._cap(number);\n  }\n\n  // trigger the 'countrychange' event\n  _triggerCountryChange() {\n    this._trigger(\"countrychange\");\n  }\n\n  /**************************\n   *  SECRET PUBLIC METHODS\n   **************************/\n\n  // this is called when the geoip call returns\n  handleAutoCountry() {\n    if (this.options.initialCountry === \"auto\") {\n      // we must set this even if there is an initial val in the input: in case the initial val is\n      // invalid and they delete it - they should see their auto country\n      this.defaultCountry = window.intlTelInputGlobals.autoCountry;\n      // if there's no initial value in the input, then update the flag\n      if (!this.telInput.value) {\n        this.setCountry(this.defaultCountry);\n      }\n      this.resolveAutoCountryPromise();\n    }\n  }\n\n  // this is called when the utils request completes\n  handleUtils() {\n    // if the request was successful\n    if (window.intlTelInputUtils) {\n      // if there's an initial value in the input, then format it\n      if (this.telInput.value) {\n        this._updateValFromNumber(this.telInput.value);\n      }\n      this._updatePlaceholder();\n    }\n    this.resolveUtilsScriptPromise();\n  }\n\n  /********************\n   *  PUBLIC METHODS\n   ********************/\n\n  // remove plugin\n  destroy() {\n    const { form } = this.telInput;\n\n    if (this.options.allowDropdown) {\n      // make sure the dropdown is closed (and unbind listeners)\n      this._closeDropdown();\n      this.selectedFlag.removeEventListener(\n        \"click\",\n        this._handleClickSelectedFlag\n      );\n      this.flagsContainer.removeEventListener(\n        \"keydown\",\n        this._handleFlagsContainerKeydown\n      );\n      // label click hack\n      const label = this._getClosestLabel();\n      if (label) {\n        label.removeEventListener(\"click\", this._handleLabelClick);\n      }\n    }\n\n    // unbind hiddenInput listeners\n    if (this.hiddenInput && form) {\n      form.removeEventListener(\"submit\", this._handleHiddenInputSubmit);\n    }\n\n    // unbind autoInsertDialCode listeners\n    if (this.options.autoInsertDialCode) {\n      if (form) {\n        form.removeEventListener(\"submit\", this._handleSubmitOrBlurEvent);\n      }\n      this.telInput.removeEventListener(\"blur\", this._handleSubmitOrBlurEvent);\n    }\n\n    // unbind key events, and cut/paste events\n    this.telInput.removeEventListener(\"keyup\", this._handleKeyupEvent);\n    this.telInput.removeEventListener(\"cut\", this._handleClipboardEvent);\n    this.telInput.removeEventListener(\"paste\", this._handleClipboardEvent);\n\n    // remove attribute of id instance: data-intl-tel-input-id\n    this.telInput.removeAttribute(\"data-intl-tel-input-id\");\n\n    // remove markup (but leave the original input)\n    const wrapper = this.telInput.parentNode;\n    wrapper.parentNode.insertBefore(this.telInput, wrapper);\n    wrapper.parentNode.removeChild(wrapper);\n\n    delete window.intlTelInputGlobals.instances[this.id];\n  }\n\n  // get the extension from the current number\n  getExtension() {\n    if (window.intlTelInputUtils) {\n      return intlTelInputUtils.getExtension(\n        this._getFullNumber(),\n        this.selectedCountryData.iso2\n      );\n    }\n    return \"\";\n  }\n\n  // format the number to the given format\n  getNumber(format) {\n    if (window.intlTelInputUtils) {\n      const { iso2 } = this.selectedCountryData;\n      return intlTelInputUtils.formatNumber(\n        this._getFullNumber(),\n        iso2,\n        format\n      );\n    }\n    return \"\";\n  }\n\n  // get the type of the entered number e.g. landline/mobile\n  getNumberType() {\n    if (window.intlTelInputUtils) {\n      return intlTelInputUtils.getNumberType(\n        this._getFullNumber(),\n        this.selectedCountryData.iso2\n      );\n    }\n    return -99;\n  }\n\n  // get the country data for the currently selected flag\n  getSelectedCountryData() {\n    return this.selectedCountryData;\n  }\n\n  // get the validation error\n  getValidationError() {\n    if (window.intlTelInputUtils) {\n      const { iso2 } = this.selectedCountryData;\n      return intlTelInputUtils.getValidationError(this._getFullNumber(), iso2);\n    }\n    return -99;\n  }\n\n  // validate the input val - assumes the global function isValidNumber (from utilsScript)\n  isValidNumber() {\n    const val = this._getFullNumber().trim();\n    return window.intlTelInputUtils\n      ? intlTelInputUtils.isValidNumber(val, this.selectedCountryData.iso2)\n      : null;\n  }\n\n  // update the selected flag, and update the input val accordingly\n  setCountry(originalCountryCode) {\n    const countryCode = originalCountryCode.toLowerCase();\n    // check if already selected\n    if (this.selectedCountryData.iso2 !== countryCode) {\n      this._setFlag(countryCode);\n      this._updateDialCode(this.selectedCountryData.dialCode);\n      this._triggerCountryChange();\n    }\n  }\n\n  // set the input value and update the flag\n  setNumber(number) {\n    // we must update the flag first, which updates this.selectedCountryData, which is used for\n    // formatting the number before displaying it\n    const flagChanged = this._updateFlagFromNumber(number);\n    this._updateValFromNumber(number);\n    if (flagChanged) {\n      this._triggerCountryChange();\n    }\n  }\n\n  // set the placeholder number typ\n  setPlaceholderNumberType(type) {\n    this.options.placeholderNumberType = type;\n    this._updatePlaceholder();\n  }\n}\n\n/********************\n *  STATIC METHODS\n ********************/\n\n// get the country data object\nintlTelInputGlobals.getCountryData = () => allCountries;\n\n// inject a <script> element to load utils.js\nconst injectScript = (path, handleSuccess, handleFailure) => {\n  // inject a new script element into the page\n  const script = document.createElement(\"script\");\n  script.onload = () => {\n    forEachInstance(\"handleUtils\");\n    if (handleSuccess) {\n      handleSuccess();\n    }\n  };\n  script.onerror = () => {\n    forEachInstance(\"rejectUtilsScriptPromise\");\n    if (handleFailure) {\n      handleFailure();\n    }\n  };\n  script.className = \"iti-load-utils\";\n  script.async = true;\n  script.src = path;\n  document.body.appendChild(script);\n};\n\n// load the utils script\nintlTelInputGlobals.loadUtils = (path) => {\n  // 2 options:\n  // 1) not already started loading (start)\n  // 2) already started loading (do nothing - just wait for the onload callback to fire, which will\n  // trigger handleUtils on all instances, invoking their resolveUtilsScriptPromise functions)\n  if (\n    !window.intlTelInputUtils &&\n    !window.intlTelInputGlobals.startedLoadingUtilsScript\n  ) {\n    // only do this once\n    window.intlTelInputGlobals.startedLoadingUtilsScript = true;\n\n    // if we have promises, then return a promise\n    if (typeof Promise !== \"undefined\") {\n      return new Promise((resolve, reject) =>\n        injectScript(path, resolve, reject)\n      );\n    }\n    injectScript(path);\n  }\n  return null;\n};\n\n// default options\nintlTelInputGlobals.defaults = defaults;\n\n// version\nintlTelInputGlobals.version = \"<%= version %>\";\n"],"names":["Object","defineProperty","module","exports","value","default","obj","key","enumerable","configurable","writable","$665014edacbfe17b$exports","instance","Constructor","TypeError","$74e7f8130373505f$var$_defineProperties","target","props","i","length","descriptor","$74e7f8130373505f$exports","protoProps","staticProps","prototype","$9eddae5a012cde57$exports","arguments","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","forEach","$9eddae5a012cde57$var$_defineProperty","parcelRequire","__esModule","$9d0333e62a332c17$var$intlTelInputGlobals","getInstance","input","id1","getAttribute","window","intlTelInputGlobals","instances","documentReady","document","readyState","$9d0333e62a332c17$var$defaults","allowDropdown","autoInsertDialCode","autoPlaceholder","customContainer","customPlaceholder","dropdownContainer","excludeCountries","formatOnDisplay","geoIpLookup","hiddenInput","initialCountry","localizedCountries","nationalMode","onlyCountries","placeholderNumberType","preferredCountries","separateDialCode","showFlags","utilsScript","$9d0333e62a332c17$var$forEachProp","callback","$9d0333e62a332c17$var$forEachInstance","method","getCountryData","allCountries","$9d0333e62a332c17$var$injectScript","path","handleSuccess","handleFailure","script","createElement","onload","onerror","className","async","src","body","appendChild","loadUtils","intlTelInputUtils","startedLoadingUtilsScript","Promise","resolve","reject","defaults","version"],"version":3,"file":"private-office.1db302e5.js.map"}